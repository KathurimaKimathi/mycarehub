scalar Date
scalar Markdown
scalar Any
scalar Decimal

type Practitioner {
  profile: UserProfile!
  license: String!
  cadre: PractitionerCadre!
  specialty: PractitionerSpecialty!
  professionalProfile: Markdown!
  averageConsultationPrice: Float!
  services: ServicesOffered!
}

type PractitionerEdge {
  cursor: String
  node: Practitioner
}

type PractitionerConnection {
  edges: [PractitionerEdge]
  pageInfo: PageInfo!
}

type KMPDUPractitioner {
  name: String!
  regno: String!
  address: String!
  qualifications: String!
  speciality: String!
  subspeciality: String!
  licensetype: String!
  active: String!
}

type KMPDUPractitionerEdge {
  cursor: String
  node: KMPDUPractitioner
}

type KMPDUPractitionerConnection {
  edges: [KMPDUPractitionerEdge]
  pageInfo: PageInfo!
}

type Cover {
  payerName: String!
  payerSladeCode: Int!
  memberNumber: String!
  memberName: String!
}

type UserProfile @key(fields: "id") {
  id: String!
  verifiedIdentifiers: [String!]!
  isApproved: Boolean!
  termsAccepted: Boolean!
  msisdns: [String!]!
  emails: [String!]!
  photoBase64: String!
  photoContentType: ContentType!
  pushTokens: [String!]!
  covers: [Cover!]!
  isTester: Boolean!
  active: Boolean!

  # optional fields
  dateOfBirth: Date
  gender: Gender
  patientID: String
  name: String
  bio: String
  language: Language
  practitionerApproved: Boolean
  practitionerTermsOfServiceAccepted: Boolean
  canExperiment: Boolean
  askAgainToSetIsTester: Boolean
  askAgainToSetCanExperiment: Boolean
  VerifiedEmails: [VerifiedEmail]
  VerifiedPhones: [VerifiedMsisdn]

  # These flags are used to distinguish previously exisiting user and
  # new users signing up. They help us create accounts for the existing
  # users in the backgroud and ask the user to set up a pin.
  hasPin: Boolean
  hasSupplierAccount: Boolean
  hasCustomerAccount: Boolean
  practitionerHasServices: Boolean
}

type VerifiedMsisdn {
  msisdn: String!
  verified: Boolean!
}

type VerifiedEmail {
  email: String!
  verified: Boolean!
}

type TesterWhitelist {
  email: String!
}

type Customer {
  userProfile: UserProfile!
  customerId: String!
  receivablesAccount: ReceivablesAccount!
  customerKYC: CustomerKYC!
  active: Boolean!
}

type ReceivablesAccount {
  id: String!
  name: String!
  isActive: Boolean!
  number: String!
  tag: String!
  description: String!
}

type CustomerKYC {
  KRAPin: String!
  occupation: String!
  idNumber: String!
  address: String!
  city: String!
  beneficiary: [Beneficiary!]
}

type ServicesOffered {
  services: [PractitionerService!]!
  otherServices: [String!]!
}

type PayablesAccount {
  id: String!
  name: String!
  isActive: Boolean!
  number: String!
  tag: String!
  description: String!
}

type Beneficiary {
  name: String!
  msisdns: [String!]
  emails: [String!]
  relationship: BeneficiaryRelationship!
  dateOfBirth: Date!
}

type Supplier {
  userProfile: UserProfile!
  supplierId: String!
  payablesAccount: PayablesAccount!
  supplierKYC: SupplierKYC!
  active: Boolean!

  accountType: AccountType!
  underOrganization: Boolean!
  isOrganizationVerified: Boolean!
  partnerType: PartnerType!

  sladeCode: String
  parentOrganizationID: String
  location: Location

}

type Location {
    id: ID!
    name: String!
    branchSladeCode: String
}

type SupplierKYC {
  accountType: AccountType!
  identificationDocType: IdentificationDocType
  identificationDocNumber: String
  identificationDocPhotoBase64: String
  identificationDocPhotoContentType: ContentType
  license: String
  cadre: PractitionerCadre
  profession: String
  kraPIN: String
  kraPINDocPhoto: String
  businessNumber: String
  businessNumberDocPhotoBase64: String
  businessNumberDocPhotoContentType: ContentType
}

type BusinessPartner {
    id: ID!
    name: String!
    sladeCode: String!
}

type BusinessPartnerEdge {
    cursor: String
    node: BusinessPartner
}

type BusinessPartnerConnection {
    edges: [BusinessPartnerEdge]
    pageInfo: PageInfo!
}

# A location is a "branch" of an organization.
type Branch {
    id: ID!
    name: String!
    organizationSladeCode: String!
    branchSladeCode: String!
}

type BranchEdge {
    cursor: String
    node: Branch
}

type BranchConnection {
    edges: [BranchEdge]
    pageInfo: PageInfo!
}



